### 1-1.js
- `var` 키워드를 사용한 변수 선언과 문자열 대입 예시
- 같은 이름의 변수를 `var`로 다시 선언할 수 있음
- `var`로 같은 변수를 재선언해도 오류가 발생하지 않음

### 1-2.js
- `var` 키워드를 사용한 변수 선언과 문자열 대입 예시
- 같은 이름의 변수를 `var`로 다시 선언할 수 있음
- `var`로 같은 변수를 재선언해도 오류가 발생하지 않음

- ### 1-3.js
- 변수 `a`에 문자열 `'abc'`를 저장한 후, 문자열 `'def'`를 추가.
- 변수 `b`와 `c`를 같은 값 `5`로 초기화한 뒤, `b`만 `7`로 변경하여 변수 간 값 변경이 독립적으로 진행됨
- `+` 연산과 변수 값의 변경, 변수 간 독립성 확인

### 1-4.js
- 객체 `obj1`을 정의하고 두 개의 속성(`a`, `b`)을 포함
- `a`는 숫자형(1), `b`는 문자열(`'bbb'`)
- JavaScript 객체는 key-value 형태로 다양한 자료형을 저장할 수 있음.

### 1-5.js

### 1-6.js
- 객체 `obj`는 두 개의 속성 `x`와 `arr`를 가짐짐
- `x`는 숫자형 값 3, `arr`는 숫자 배열 `[3, 4, 5]`
- 중첩된 데이터 구조를 정의할 때 유용함.

### 1-7.js
- 변수 `a`와 `b`는 숫자형(primitive) 데이터를 복사하므로, `b`는 `a`의 값을 그대로 복사함.
- 객체 `obj1`과 `obj2`는 참조(reference)형이므로, `obj2`는 `obj1`을 가리키는 참조를 공유.

### 1-8.js
- `a`와 `b`는 기본형(primitive) 변수, `b = a` 이후 `b`의 값을 변경해도 `a`에는 영향을 주지 않음.
- `obj1`과 `obj2`는 참조형(reference) 객체로, `obj2 = obj1` 이후 `obj2.c`를 변경하면 `obj1.c`도 함께 변경됩니다.
- 이 예제를 통해 기본형은 **값 복사**, 참조형은 **주소(참조) 복사**가 이루어짐을 확인할 수 있습니다.

### 1-8.js
- `a`와 `b`는 기본형(primitive) 변수로, `b = a` 이후 `b`의 값을 변경해도 `a`에는 영향을 주지 않음
- `obj1`과 `obj2`는 참조형 객체, `obj2 = obj1` 이후 `obj2.c`를 변경하면 `obj1.c`도 함께 변경.

### 1-9.js
- `a`와 `b`는 기본형 변수로 `b = a` 이후 `b` 값을 바꿔도 `a`에는 영향이 없음.
- `obj1`과 `obj2`는 참조형 객체로, 처음에는 같은 객체를 참조함.
- `obj2 = { c: 20, d: 'ddd' }`로 새로운 객체를 재할당하면, `obj2`는 더 이상 `obj1`과 연결 X.
- 따라서 `obj2`를 변경해도 `obj1`에는 영향이 없는 것을 알 수 있음.

### 1-10.js
- 객체 `user`를 함수 `changeName`에 인자로 전달하여 이름을 변경.
- 함수 내부에서 `var newUser = user`로 같은 객체를 참조하고 있음, `newUser.name = newName`은 `user.name`도 
  함께 변경
- 결과적으로 `user`와 `user2`는 같은 객체를 가리키므로 `user === user2`는 `true` 임을 알 수 있음.

### 1-11.js
- 객체 `user`를 함수에 전달하지만, 함수 내부에서 새로운 객체를 만들어 반환.
- 새로운 객체는 `name`만 변경하고, 나머지 속성(`gender`)은 원본 `user`에서 복사해 사용.
- 이로 인해 `user`와 `user2`는 서로 다른 객체이며, `user !== user2`는 `true` 임을 알 수 있음.

### 1-12.js
- 함수 `copyObject`는 전달받은 객체 `target`의 모든 속성을 새로운 객체 `result`에 복사.
- `for...in` 문을 사용해 속성명을 반복하며, 각 속성의 값을 복사합니다.
- 얕은 복사(shallow copy)로, 중첩 객체는 참조만 복사됨.
- 원본 객체를 변경하지 않고 복사본을 만들어 사용할 수 있음.

### 1-13.js
- `copyObject` 함수를 사용하여 객체 `user`를 복사해 `user2`를 생성.
- 복사본 `user2`의 `name` 속성을 `'Jung'`으로 변경해도 원본 `user`의 `name`은 그대로 유지.
- `user !== user2`는 `true`이며, 두 객체는 서로 다른 메모리 주소를 가지는 독립된 객체.

### 1-14.js
- `copyObject` 함수를 사용하여 객체 `user`를 복사한 `user2`는 독립된 개체.
- `user.name`과 `user2.name`은 서로 다르게 변경되어 독립성이 유지됨.
- 하지만 중첩된 객체 `urls`는 얕은 복사로 인해 동일한 참조를 공유함.

### 1-15.js
- `copyObject` 함수를 사용해 `user` 객체를 복사 후, 중첩 객체 `urls`도 별도로 복사하여 `user2`에 할당.
- `user.urls`와 `user2.urls`는 서로 다른 객체가 되어 참조가 분리죔.
- `user.urls.portfolio`와 `user2.urls.portfolio`는 서로 영향을 주지 않으며, 변경 시 값이 독립적으로 유지함.

### 1-16.js
- 함수 `copyObjectDeep`는 객체를 재귀적 순회 진행, 모든 하위 속성까지 복사하는 깊은 복사(deep copy)를 수행.
- `typeof target === 'object' && target !== null` 구문으로 객체만 재귀 호출하고, 원시 값은 그대로 반환.

### 1-17.js
- `copyObjectDeep` 를 사용해 객체 `obj`를 깊은 복사하여 `obj2`를 생성함.
- 복사 후 `obj2.a`, `obj2.b.c`, `obj.b.d[1]` 값을 각각 수정하지만, 두 객체는 서로 영향을 주지 않음.
- `obj`와 `obj2`는 중첩 객체와 배열까지 모두 다른 참조를 가지므로 복사가 정상적으로 동작함을 알 수 있음

### 1-18.js
- `copyObjectViaJSON` 함수는 객체를 'JSON.stringify()'로 문자열화한 뒤, `JSON.parse()`로 다시 객체화함
   --> 깊은 복사
- 이 방식은 중첩 객체와 배열 구조를 복사할 수 있지만, `function`은 JSON으로 변환되지 않음.
- 결과적으로 `obj2`에는 `func1`, `func2`가 존재하지 않음.
- 간단한 구조의 깊은 복사에는 JSON 방식이 유용하지만, 함수나 `undefined`, `Symbol` 등은 제외하는 한계 존재.

### 1-19.js
- JavaScript에서 `undefined`가 발생하는 주요 경우들.

### 1-20.js
- JavaScript에서 배열의 'empty' 과 명시적 `undefined` 값의 차이를 보여줌.

### 1-21.js
- `undefined` 값이 명시된 배열과, empty slot이 있는 배열을 다양한 함수(`forEach`, `map`, `filter`, `reduce`)
   에 적용하여 동작 차이를 비교함.

### 1-22.js
- JavaScript에서 `null`의 역할 확인 할 수 있음. `null`은 원시값이지만 `typeof`는 `object`로 반환함.

### 2-1.js
- 함수 스코프와 변수 호이스팅(hoisting)이 의 동작 방식을 보여줌.
- 같은 이름의 변수라도 스코프가 다르면 완전히 별개의 변수이며, 호이스팅으로 인해 예기치 않은 결과가 발생할 수 
   있다는 점을 알 수 있음

### 2-2.js
- 함수 매개변수와 변수 선언이 동일한 이름일 때, JavaScript가 어떻게 처리하는지를 보여줌.
- 매개변수가 변수 선언보다 우선하여 바인딩되며, 이후의 var 선언은 중복 선언으로 간주되어 무시된다는 점을 알 수 있음.


### 2-3.js
- 함수 내부에서 같은 이름의 지역 변수를 여러 번 선언할 경우, JavaScript가 이를 어떻게 호이스팅하여 처리하는지를 
  보여줌.
- var는 중복 선언을 허용하며, 선언만 호이스팅되고 초기화는 실행 시점에 이뤄진다는 특징을 확인 할 수 있음.

### 2-4.js
- 동일한 변수명을 가진 `var` 선언이 여러 번 나올 경우, JavaScript가 어떻게 처리하는지를 보여줌.
- var 선언이 중복 선언 가능하고, 모두 같은 스코프 내 동일 변수로 취급됨을 알 수 있음.

### 2-5.js
- 같은 식별자(`b`)를 함수 선언과 변수 선언에 모두 사용했을 때, JavaScript가 어떻게 호이스팅 순서를 적용하는지 
   보여줌
- 같은 이름의 함수와 변수가 존재할 경우, 함수 선언이 우선 호이스팅됨.

### 2-6.js
- 함수 `b()`와 변수 `b`가 같은 이름으로 선언되었을 때, JavaScript에서 호이스팅을 수행 및 처리를 보여줌
- JavaScript의 선언 수집 우선순위는 함수 > 변수.

### Ch2-7.js
- 함수 선언이 아닌 함수 표현식을 사용했을 때, JavaScript에서 호이스팅 방식은 달라짐.

### 2-8.js
- 함수 선언문과 함수 표현식의 차이를 비교하고, 각 경우에 함수명을 어떻게 사용할 수 있는지 확인 할 수 있음.
- 함수 정의 방식에 따라 이름의 스코프가 달라짐.

### Ch2-9.js
- 이 예제는 **함수 선언문**과 **함수 표현식**의 **호이스팅 처리 차이**를 보여줍니다.
- 함수 선언문은 전체가 끌어올려지지만,
함수 표현식은 변수 선언만 끌어올려지고 대입은 나중에 이루어진다는 점을 명확히 보여줍니다.

### 2-10.js
-  함수 표현식은 대입 후에만 호출 가능하며, 변수 선언은 호이스팅되지만 초기화는 실행 시점에 이루어 짐.

### 2-11.js
- 동일한 이름의 함수 선언이 여러 번 있을 때, JavaScript는 가장 마지막 선언을 기준으로 동작함.
- 함수 선언이 중복될 경우, 마지막 선언이 유효함.

### 2-12.js
- 함수 표현식은 변수만 호이스팅되며, 초기화(함수 할당)는 실행 시점에 이루어짐.
- 함수 표현식은 선언이 아닌 값의 대입이므로, 선언 시점 이전에는 사용할 수 없고, 재할당도 가능함을 보여줍니다.

### 2-13.js
- 함수 내부에서 변수명이 중복될 경우, 호이스팅으로 인해 상위 스코프의 변수 참조가 막히는 현상을 보여줍니다.
- 내부 스코프에서 같은 이름의 변수가 선언되면 상위 스코프의 변수 접근이 Shadowing 됨.

### 2-14.js
- `console.dir()`을 사용하여 함수 객체 `inner`의 내부 구조를 확인 가능.
- JavaScript의 함수 객체가 단순한 코드 덩어리가 아니라, 실행 컨텍스트와 스코프 체인을 포함하는 객체임.

## 2-15.js
- 함수 `inner`가 상위 스코프인 `outer` 함수의 지역 변수 `b`를 참조할 수 있음.
- 또한 `console.dir(inner)`을 통해 `inner` 함수 객체의 내부 구조를 확인할 수 있습니다.
- 함수가 선언된 시점의 스코프 체인을 기억한다는 클로저의 개념을 시각적으로 확인할 수 있게 해줍니다.

### 2-16.js
- `debugger` 키워드를 사용해 실행 도중 스코프 체인을 개발자 도구에서 직접 분석할 수 있음.

